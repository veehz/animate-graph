<!DOCTYPE html>
<html>

<head>
    <link rel="stylesheet" href="../../dist/animate-graph.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../../dist/animate-graph.umd.js"></script>
    <script src="https://veehz.github.io/torch/build/browser/torch.browser.umd.js"></script>
</head>

<body>
    <div id="controls" style="margin-bottom: 10px;">
        <!-- Slider will be injected here -->
    </div>
    <div id="graph-container" style="border: 1px solid #ccc; height: 600px;"></div>
    <script>
        const { Graph, Node, Animator, Slider } = AnimateGraph;
        const torch = window.torch;

        const a = new torch.Tensor([1, 2, 3], { requires_grad: true });
        console.log(a);

        const b = new torch.Tensor([4, 5, 6], { requires_grad: true });
        console.log(b);

        const c = a.mul(b);
        console.log(c);

        const d = c.sum();

        const animator = new Animator();
        const slider = new Slider("#controls", animator);

        const graph = new Graph("#graph-container", {
            height: document.getElementById("graph-container").clientHeight,
            width: document.getElementById("graph-container").clientWidth
        });

        function buildGraph(graph, tensor) {
            function buildAccumulateGrad(operation) {
                const tensorNode = new Node(operation.variable.id, "t"+operation.variable.id);
                const accumNode = new Node(operation.id, "Accum");
                graph.insertNode(tensorNode);
                graph.insertNodeAfter(accumNode, tensorNode);
                return accumNode;
            }

            function buildOperation(operation) {
                if (operation instanceof torch.AccumulateGrad) {
                    return buildAccumulateGrad(operation);
                }

                const operationsBefore = [];
                for (const op of operation.next_functions) {
                    operationsBefore.push(buildOperation(op));
                }

                const operationNode = new Node(operation.id, operation.constructor.name);
                graph.insertNodeAfter(operationNode, operationsBefore);
                return operationNode;
            }

            const output = new Node(tensor.id, "t"+tensor.id);
            if (tensor.grad_fn) {
                const operation = buildOperation(tensor.grad_fn);
                graph.insertNodeAfter(output, operation);
            } else {
                graph.insertNode(output);
            }
        }

        buildGraph(graph, d);
        animator.snap(graph);

        torch.eventBus.addEventListener(torch.events.TENSOR_BEFORE_BACKWARD, (e) => {
            graph.highlight(e.detail.tensor.id);
            animator.snap(graph);
        });
        torch.eventBus.addEventListener(torch.events.TENSOR_AFTER_BACKWARD, (e) => {
            graph.remove_highlight(e.detail.tensor.id);
            animator.snap(graph);
        });

        torch.eventBus.addEventListener(torch.events.OPERATION_BEFORE_BACKWARD, (e) => {
            graph.highlight(e.detail.operation.id);
            animator.snap(graph);
        });
        torch.eventBus.addEventListener(torch.events.OPERATION_AFTER_BACKWARD, (e) => {
            graph.remove_highlight(e.detail.operation.id);
            animator.snap(graph);
        });
        
        torch.eventBus.addEventListener(torch.events.OPERATION_AFTER_ACCUMULATE_GRAD, (e) => {
            graph.highlight(e.detail.operation.variable.id);
            animator.snap(graph);

            graph.label(e.detail.operation.variable.id, `grad=[${e.detail.operation.variable.grad.data}]`);

            graph.remove_highlight(e.detail.operation.variable.id);
            animator.snap(graph);
        });

        d.backward();

        animator.last();
    </script>
</body>

</html>